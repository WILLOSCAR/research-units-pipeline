Interfaces define the action space an agent can execute and the observations it can reliably incorporate; this contract often determines robustness more directly than a change in the base model. Early agent designs make the loop explicit by interleaving reasoning with grounded actions, while tool-use training expands the action set beyond natural language, pushing schema design and orchestration policies to the foreground [@Yao2022React; @Schick2023Toolformer].

Seen through this lens, comparisons hinge on what is held fixed. Tool catalogs, permissions, and error semantics can reshape outcomes in evaluations that model realistic API complexity, so interface choices are only interpretable when paired with protocol assumptions [@Kim2026Beyond; @Mohammadi2025Evaluation]. The next two subsections separate loop semantics (what counts as state, action, and recovery) from interface and orchestration (how tools are selected, invoked, and audited), so later chapters can treat planning and memory as decisions made within a well-defined contract rather than as free-form prompting tricks [@Zhang2025Security; @Mohammadi2025Evaluation].
